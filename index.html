<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Bunny Tower</title>
    
    <!-- CSS Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    
    <!-- React Dependencies (Cloudflare CDN for better reliability) -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX compilation in browser -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #020617; /* Dark background to match game */
            font-family: 'Inter', sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #root {
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }
        .vignette {
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 50;
        }
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #06b6d4;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root">
        <div id="loading-message">
            <h1 class="text-2xl font-bold animate-pulse">LOADING SYSTEM...</h1>
            <p class="text-sm text-slate-500 mt-2">Connecting to Neural Net (Internet Required)</p>
        </div>
    </div>

    <!-- Main Game Script -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONSTANTS ---
        const GameStatus = {
            MENU: 'MENU',
            PLAYING: 'PLAYING',
            GAMEOVER: 'GAMEOVER'
        };

        // --- HELPER FUNCTIONS ---
        const drawRoundRect = (ctx, x, y, w, h, r) => {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + r, y, r);
          ctx.closePath();
        };

        const getLocalCommentary = (score, height, combo) => {
            if (score < 50) return "Did you even try? My grandmother jumps higher.";
            if (score < 200) return "Warm up complete. Now try actually playing.";
            if (score < 500) return "Not bad for a beginner. Keep your momentum up.";
            if (score < 1000) return "Now we're getting somewhere! Nice hops.";
            if (score < 2000) return "Impressive flow. You're understanding the physics.";
            if (score < 5000) return "GODLIKE MOVEMENT! You are the Bunny King.";
            return "Are you cheating? That score is impossible!";
        };

        // --- HUD COMPONENT ---
        const HUD = ({ score, height, combo, comboTimer = 0, speed, isMuted, onToggleMute }) => {
            const momentumBorder = combo > 8 ? "border-red-500 shadow-[0_0_10px_rgba(239,68,68,0.5)]" : "border-pink-500/30";
            const momentumText = combo > 8 ? "text-red-500" : "text-pink-400";

            return (
                <div 
                className="fixed top-0 left-0 w-full p-4 pointer-events-none flex justify-center items-start z-40 text-white font-orbitron"
                style={{ paddingTop: 'calc(1rem + env(safe-area-inset-top))' }}
                >
                <div className="w-full max-w-[600px] flex justify-between items-start">
                    <div className="space-y-1 pointer-events-auto">
                    <div className="bg-black/60 backdrop-blur-md border border-cyan-500/30 px-4 py-2 rounded-lg shadow-lg">
                        <p className="text-xs text-cyan-400 uppercase tracking-widest">Score</p>
                        <p className="text-2xl font-bold font-mono">{Math.floor(score)}</p>
                    </div>
                    <div className="bg-black/60 backdrop-blur-md border border-purple-500/30 px-4 py-2 rounded-lg shadow-lg">
                        <p className="text-xs text-purple-400 uppercase tracking-widest">Height</p>
                        <p className="text-xl font-bold font-mono">{Math.floor(height)}m</p>
                    </div>
                    </div>

                    <div className="flex flex-col items-end space-y-2 pointer-events-auto">
                    <button 
                        onClick={onToggleMute}
                        className="bg-black/60 backdrop-blur-md border border-white/20 p-2 rounded-lg hover:bg-white/10 transition-colors pointer-events-auto"
                    >
                        {isMuted ? (
                        <span className="text-red-500 text-xs font-bold">MUTED</span>
                        ) : (
                        <span className="text-green-500 text-xs font-bold">AUDIO ON</span>
                        )}
                    </button>

                    {combo > 0 && (
                        <div className="flex flex-col items-end space-y-1">
                        <div className="bg-yellow-500 text-black px-4 py-1 rounded-full animate-bounce shadow-[0_0_15px_rgba(234,179,8,0.6)]">
                            <p className="text-sm font-black italic">COMBO x{combo}!</p>
                        </div>
                        <div className="w-32 h-2 bg-zinc-800 rounded-full overflow-hidden border border-white/20">
                            <div 
                            className="h-full bg-gradient-to-r from-yellow-500 to-red-500 transition-all duration-75 ease-linear"
                            style={{ width: `${Math.min(100, comboTimer * 100)}%` }}
                            />
                        </div>
                        </div>
                    )}
                    <div className={`bg-black/60 backdrop-blur-md border px-4 py-2 rounded-lg transition-colors duration-300 shadow-lg ${momentumBorder}`}>
                        <p className={`text-xs uppercase tracking-widest text-right ${momentumText}`}>Momentum</p>
                        <p className="text-xl font-bold font-mono">{(speed * 10).toFixed(1)} <span className="text-xs">km/h</span></p>
                    </div>
                    </div>
                </div>
                </div>
            );
        };

        // --- GAMEOVER COMPONENT ---
        const GameOver = ({ score, height, maxSpeed, combo, onRestart }) => {
            const [commentary, setCommentary] = useState("");

            useEffect(() => {
                setCommentary(getLocalCommentary(score, height, combo));
            }, [score, height, combo]);

            return (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-xl z-50 flex items-center justify-center p-6 animate-in fade-in duration-300">
                <div className="max-w-md w-full bg-zinc-900 border-2 border-pink-500 p-8 rounded-2xl shadow-[0_0_50px_rgba(236,72,153,0.3)] text-center space-y-6">
                    <h1 className="text-4xl font-orbitron font-bold text-white uppercase tracking-tighter italic">Run Terminated</h1>
                    
                    <div className="grid grid-cols-3 gap-2">
                    <div className="bg-zinc-800 p-3 rounded-xl border border-zinc-700">
                        <p className="text-zinc-400 text-[10px] uppercase">Total Score</p>
                        <p className="text-lg font-bold text-cyan-400 font-mono">{Math.floor(score)}</p>
                    </div>
                    <div className="bg-zinc-800 p-3 rounded-xl border border-zinc-700">
                        <p className="text-zinc-400 text-[10px] uppercase">Peak Height</p>
                        <p className="text-lg font-bold text-purple-400 font-mono">{Math.floor(height)}m</p>
                    </div>
                    <div className="bg-zinc-800 p-3 rounded-xl border border-zinc-700">
                        <p className="text-zinc-400 text-[10px] uppercase">Max Speed</p>
                        <p className="text-lg font-bold text-pink-400 font-mono">{(maxSpeed * 10).toFixed(0)}</p>
                    </div>
                    </div>

                    <div className="bg-zinc-800/50 p-4 rounded-xl border border-zinc-700 italic text-zinc-300">
                    <p className="text-sm">"{commentary}"</p>
                    </div>

                    <button
                    onClick={onRestart}
                    className="w-full bg-gradient-to-r from-cyan-500 to-purple-600 hover:from-cyan-400 hover:to-purple-500 text-white font-orbitron font-bold py-4 rounded-xl transition-all transform hover:scale-105 active:scale-95 shadow-lg border-t border-white/20"
                    >
                    RETRY SYSTEM
                    </button>
                </div>
                </div>
            );
        };

        // --- APP LOGIC & CONSTANTS ---
        const LOGICAL_WIDTH = 600;
        const CANVAS_HEIGHT = 800; // Initial fallback
        const PLATFORM_HEIGHT = 20;

        // Physics
        const GRAVITY = 0.6;           
        const BASE_JUMP_FORCE = -15.0;  
        const MOMENTUM_SCALE = 0.3;    

        const AIR_ACCEL = 0.8;          
        const GROUND_FRIC = 0.82;       
        const AIR_FRIC = 0.985;         
        const MAX_HORIZONTAL_SPEED = 15; 
        const JUMP_BUFFER_MS = 200;     

        const FLOOR_HEIGHT = 100;

        // Combo
        const COMBO_MAX_TIME_MS = 3000;
        const GROUND_TOLERANCE_MS = 250; 
        const PLATFORM_GAP_AVG = 140;

        // --- AUDIO ENGINE ---
        class MusicEngine {
            ctx = null;
            isPlaying = false;
            nextNoteTime = 0;
            tempo = 125;
            lookahead = 25.0;
            scheduleAheadTime = 0.1;
            beatCount = 0;
            timerID = null;
            
            bassFreqs = [55, 55, 55, 55, 65.41, 65.41, 49, 49]; 
            
            init() {
                if (!this.ctx) {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    if (AudioContextClass) {
                        this.ctx = new AudioContextClass();
                    }
                } catch (e) {
                    console.warn("AudioContext initialization failed", e);
                }
                }
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
                }
            }

            start() {
                if (this.isPlaying) return;
                this.init();
                this.isPlaying = true;
                this.beatCount = 0;
                if (this.ctx) this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.scheduler();
            }

            stop() {
                this.isPlaying = false;
                if (this.timerID) window.clearTimeout(this.timerID);
            }

            scheduler() {
                if (!this.isPlaying || !this.ctx) return;
                while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beatCount, this.nextNoteTime);
                this.nextNote();
                }
                this.timerID = window.setTimeout(() => this.scheduler(), this.lookahead);
            }

            nextNote() {
                const secondsPerBeat = 60.0 / this.tempo;
                this.nextNoteTime += 0.25 * secondsPerBeat;
                this.beatCount++;
            }

            scheduleNote(beatNumber, time) {
                if (!this.ctx) return;

                const step = beatNumber % 16;
                const bar = Math.floor(beatNumber / 16) % 8;

                if (step % 4 === 0) {
                this.playKick(time);
                }

                if (step % 2 === 0 || (step === 15)) {
                this.playHiHat(time, step % 4 === 0 ? 0.05 : 0.03); 
                }

                if (step === 4 || step === 12) {
                this.playSnare(time);
                }

                if (step % 2 === 0) {
                const note = this.bassFreqs[bar % this.bassFreqs.length];
                if (step !== 0 || bar % 4 === 3) { 
                    this.playBass(time, note);
                }
                }
                
                if (Math.random() > 0.8 && step % 2 !== 0) {
                this.playSynth(time, 440 + Math.random() * 220);
                }
            }

            playKick(time) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.8, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.5);
            }

            playSnare(time) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(100, time);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.2);
            }

            playHiHat(time, vol) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'square';
                osc.frequency.value = 8000;
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                
                gain.gain.setValueAtTime(vol * 0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start(time);
                osc.stop(time + 0.05);
            }

            playBass(time, freq) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(400, time);
                filter.frequency.linearRampToValueAtTime(100, time + 0.2);
                
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.linearRampToValueAtTime(0.01, time + 0.2);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start(time);
                osc.stop(time + 0.2);
            }
            
            playSynth(time, freq) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, time);
                gain.gain.setValueAtTime(0.1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                osc.start(time);
                osc.stop(time + 0.3);
            }
        }

        const musicEngine = new MusicEngine();

        // --- MAIN APP COMPONENT ---
        const App = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            const [dimensions, setDimensions] = useState({ 
                width: Math.max(320, typeof window !== 'undefined' ? window.innerWidth : 640), 
                height: Math.max(400, typeof window !== 'undefined' ? window.innerHeight : 800),
                logicalHeight: 800,
                scale: 1
            });

            const [gameState, setGameState] = useState({
                score: 0,
                bestScore: 0,
                height: 0,
                maxHeight: 0,
                combo: 0,
                comboTimer: 0,
                maxSpeed: 0,
                status: GameStatus.MENU,
                speedMultiplier: 1.0,
                isMuted: false,
                actionText: undefined
            });

            const playerRef = useRef({
                x: LOGICAL_WIDTH / 2 - 16,
                y: 800 - 150,
                vx: 0,
                vy: 0,
                width: 32,
                height: 32,
                grounded: false,
                jumpHeld: false,
                speed: 0,
            });

            const platformsRef = useRef([]);
            const starsRef = useRef([]);
            const particlesRef = useRef([]);
            const keysRef = useRef({});
            const cameraY = useRef(0);
            const lastTime = useRef(0);
            
            const jumpBufferTime = useRef(0); 
            const lastPlatformY = useRef(0); 
            const autoScrollSpeed = useRef(0);
            const comboTimeRef = useRef(0); 
            const groundTimeRef = useRef(0); 
            const lastGroundDuration = useRef(0); 

            const touchStartRef = useRef([]);

            // Responsive Scaling
            useEffect(() => {
                const handleResize = () => {
                    let w = window.innerWidth;
                    let h = window.innerHeight;
                    
                    if (!w || w <= 0) w = 640;
                    if (!h || h <= 0) h = 800;
                    
                    let scale = w / LOGICAL_WIDTH;
                    if (w > h * 1.2) { 
                        scale = h / 800; 
                    }

                    if (scale < 0.001) scale = 0.001;

                    const logicalHeight = h / scale;
                    
                    setDimensions({
                        width: w,
                        height: h,
                        logicalHeight: logicalHeight,
                        scale: scale
                    });
                };
                window.addEventListener('resize', handleResize);
                handleResize(); 
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // --- TOUCH CONTROLS ---
            const handleTouchStart = (e) => {
                const w = window.innerWidth;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    touchStartRef.current.push({ id: t.identifier, x: t.clientX, y: t.clientY });
                }
                updateTouchKeys(e.touches, w);
            };

            const handleTouchMove = (e) => {
                const w = window.innerWidth;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const start = touchStartRef.current.find(s => s.id === t.identifier);
                    if (start) {
                        const dy = t.clientY - start.y;
                        if (dy < -40) { // Swipe Up
                            jumpBufferTime.current = performance.now(); 
                            start.y = t.clientY; 
                        }
                    }
                }
                updateTouchKeys(e.touches, w);
            };

            const handleTouchEnd = (e) => {
                const w = window.innerWidth;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    touchStartRef.current = touchStartRef.current.filter(s => s.id !== t.identifier);
                }
                updateTouchKeys(e.touches, w);
            };

            const updateTouchKeys = (touches, w) => {
                let left = false;
                let right = false;
                const midX = w / 2;

                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (t.clientX < midX) left = true;
                    else right = true;
                }
                keysRef.current['ArrowLeft'] = left;
                keysRef.current['ArrowRight'] = right;
            };

            const initStars = useCallback((lHeight) => {
                const stars = [];
                const safeHeight = (Number.isFinite(lHeight) && lHeight > 0) ? lHeight : 800;
                for (let i = 0; i < 200; i++) {
                const depth = Math.random(); 
                stars.push({
                    x: Math.random() * LOGICAL_WIDTH,
                    y: Math.random() * safeHeight * 2, 
                    size: Math.random() * 2.5 + 0.5,
                    speed: depth * 0.8 + 0.2, 
                    alpha: Math.random() * 0.7 + 0.3
                });
                }
                starsRef.current = stars;
            }, []);

            const spawnParticles = (x, y, color, count = 10) => {
                for(let i=0; i<count; i++) {
                    particlesRef.current.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 1.0,
                        color: color,
                        size: Math.random() * 3 + 1
                    });
                }
            };

            const generatePlatform = (y) => {
                if (!Number.isFinite(y)) y = 0;

                const heightLevel = Math.abs(y); 
                const difficultyFactor = Math.min(heightLevel / 10000, 1.0); 
                
                const baseWidth = 120 - (60 * difficultyFactor); 
                const width = Math.max(40, baseWidth + Math.random() * 40);

                const moveChance = 0.15 + (difficultyFactor * 0.6);
                const isMoving = Math.random() < moveChance;

                return {
                x: Math.random() * (LOGICAL_WIDTH - width),
                y: y,
                width: width,
                height: PLATFORM_HEIGHT,
                type: isMoving ? 'moving' : 'normal',
                direction: Math.random() > 0.5 ? 1 : -1,
                };
            };

            const initPlatforms = useCallback((startFloorY) => {
                const platforms = [];
                const safeStartY = Number.isFinite(startFloorY) ? startFloorY : 700;
                for (let i = 1; i < 20; i++) {
                platforms.push(generatePlatform(safeStartY - i * 140));
                }
                platformsRef.current = platforms;
            }, []);

            const resetGame = () => {
                const worldFloorY = dimensions.logicalHeight - FLOOR_HEIGHT;
                
                playerRef.current = {
                x: LOGICAL_WIDTH / 2 - 16,
                y: worldFloorY - 32,
                vx: 0,
                vy: 0,
                width: 32,
                height: 32,
                grounded: true,
                jumpHeld: false,
                speed: 0,
                };
                cameraY.current = 0;
                autoScrollSpeed.current = 0;
                lastPlatformY.current = worldFloorY;
                jumpBufferTime.current = 0;
                comboTimeRef.current = 0;
                groundTimeRef.current = 0;
                lastGroundDuration.current = 0;
                keysRef.current = {}; 
                particlesRef.current = [];
                
                initPlatforms(worldFloorY);
                initStars(dimensions.logicalHeight);
                setGameState(prev => ({
                ...prev,
                score: 0,
                bestScore: prev.bestScore,
                height: 0,
                maxHeight: 0,
                combo: 0,
                comboTimer: 0,
                maxSpeed: 0,
                status: GameStatus.PLAYING,
                speedMultiplier: 1.0,
                actionText: undefined
                }));
            };

            const showActionText = (text, x, y) => {
                setGameState(prev => ({
                ...prev,
                actionText: { text, opacity: 1.0, x, y }
                }));
            };

            const toggleMute = () => {
                setGameState(prev => {
                const newMuted = !prev.isMuted;
                if (newMuted) {
                    if (musicEngine.ctx) musicEngine.ctx.suspend();
                } else {
                    musicEngine.resume();
                }
                return { ...prev, isMuted: newMuted };
                });
            };

            const update = (dt) => {
                if (gameState.status !== GameStatus.PLAYING) return;

                const worldFloorY = dimensions.logicalHeight - FLOOR_HEIGHT;
                const dtMs = dt * 16.67;
                const player = playerRef.current;
                const keys = keysRef.current;
                const now = performance.now();

                // 0. Particles
                for (let i = particlesRef.current.length - 1; i >= 0; i--) {
                    const p = particlesRef.current[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    if(p.life <= 0) particlesRef.current.splice(i, 1);
                }

                // 1. Text Fade
                if (gameState.actionText) {
                setGameState(prev => {
                    if (!prev.actionText) return prev;
                    const newOp = prev.actionText.opacity - 0.02;
                    if (newOp <= 0) return { ...prev, actionText: undefined };
                    return { ...prev, actionText: { ...prev.actionText, opacity: newOp, y: prev.actionText.y - 0.5 } };
                });
                }

                // 2. Combo Logic
                if (gameState.combo > 0) {
                comboTimeRef.current -= dtMs;
                if (comboTimeRef.current <= 0) {
                    setGameState(prev => ({ ...prev, combo: 0, comboTimer: 0 }));
                    showActionText("COMBO END", player.x, player.y - 40);
                }
                }

                if (player.grounded) {
                groundTimeRef.current += dtMs;
                if (groundTimeRef.current > GROUND_TOLERANCE_MS && gameState.combo > 0) {
                    setGameState(prev => ({ ...prev, combo: 0, comboTimer: 0 }));
                    comboTimeRef.current = 0;
                    showActionText("TOO SLOW!", player.x, player.y - 40);
                }
                } else {
                groundTimeRef.current = 0;
                }

                // 3. Auto-Scroll
                if (gameState.height > 5) {
                const targetSpeed = 0.8 + (gameState.height * 0.006); 
                autoScrollSpeed.current = autoScrollSpeed.current * 0.99 + targetSpeed * 0.01;
                cameraY.current -= autoScrollSpeed.current * dt;
                }

                // 4. Movement
                const moveDir = (keys['ArrowLeft'] || keys['a']) ? -1 : (keys['ArrowRight'] || keys['d']) ? 1 : 0;
                const comboSpeedBoost = Math.min(gameState.combo * 1.5, 12);
                const currentMaxSpeed = MAX_HORIZONTAL_SPEED + comboSpeedBoost;

                if (player.grounded) {
                player.vx += moveDir * AIR_ACCEL * 2.5; 
                player.vx *= GROUND_FRIC;
                } else {
                player.vx += moveDir * AIR_ACCEL;
                player.vx *= AIR_FRIC;
                }

                if (Math.abs(player.vx) > currentMaxSpeed) {
                player.vx = Math.sign(player.vx) * currentMaxSpeed;
                }
                
                if (!player.grounded) {
                    player.vy += GRAVITY;
                }

                // 5. Jump
                const jumpPressed = keys[' '] || keys['ArrowUp'] || keys['w'];
                
                if (jumpPressed) {
                    jumpBufferTime.current = now;
                }

                const canJump = player.grounded;
                const wantsToJump = (now - jumpBufferTime.current) < JUMP_BUFFER_MS;

                if (canJump && wantsToJump) {
                    jumpBufferTime.current = 0; 
                    lastGroundDuration.current = groundTimeRef.current;
                    let force = BASE_JUMP_FORCE;
                    force -= Math.abs(player.vx) * MOMENTUM_SCALE;
                    force = Math.max(force, -25);
                    player.vy = force;
                    player.grounded = false;
                    spawnParticles(player.x + 16, player.y + 32, '#fff', 5);
                }

                player.x += player.vx;
                player.y += player.vy;

                if (player.x < 0) {
                player.x = 0;
                player.vx *= -0.8; 
                }
                if (player.x + player.width > LOGICAL_WIDTH) {
                player.x = LOGICAL_WIDTH - player.width;
                player.vx *= -0.8; 
                }

                // 6. Collision
                let wasGrounded = player.grounded;
                let isNowGrounded = false;

                if (gameState.height < 50) {
                    if (player.y + player.height >= worldFloorY) {
                    player.y = worldFloorY - player.height;
                    player.vy = 0;
                    isNowGrounded = true;
                    if (!wasGrounded) {
                        spawnParticles(player.x + 16, player.y + 32, '#06b6d4', 8);
                        if (lastPlatformY.current < worldFloorY - 50) {
                            setGameState(prev => ({ ...prev, combo: 0, comboTimer: 0 }));
                            comboTimeRef.current = 0;
                        }
                        lastPlatformY.current = worldFloorY;
                    }
                    }
                }

                if (player.vy >= 0) { 
                platformsRef.current.forEach(p => {
                    if (p.type === 'moving' && p.direction) {
                    const moveSpeed = 2.0 + (gameState.height * 0.003);
                    p.x += p.direction * moveSpeed;
                    if (p.x <= 0) {
                        p.x = 0;
                        p.direction = 1;
                    } else if (p.x + p.width >= LOGICAL_WIDTH) {
                        p.x = LOGICAL_WIDTH - p.width;
                        p.direction = -1;
                    }
                    }

                    const playerCenter = player.x + player.width / 2;
                    const snapThreshold = Math.max(5, player.vy + 5); 

                    if (playerCenter > p.x && playerCenter < p.x + p.width &&
                        player.y + player.height >= p.y &&
                        player.y + player.height <= p.y + p.height + snapThreshold) {
                    
                    player.y = p.y - player.height;
                    player.vy = 0;
                    isNowGrounded = true;
                    
                    if (!wasGrounded) {
                        spawnParticles(player.x + 16, player.y + 32, '#ec4899', 8);
                        const heightDiff = lastPlatformY.current - p.y; 
                        
                        if (heightDiff > 10) { 
                            const floors = Math.max(1, Math.round(heightDiff / PLATFORM_GAP_AVG));
                            const isFastJump = lastGroundDuration.current < GROUND_TOLERANCE_MS;
                            let newCombo = gameState.combo;
                            let scoreAdd = 0;
                            let actionMsg = undefined;

                            if (gameState.combo === 0) {
                                if (floors >= 2) {
                                    newCombo = floors;
                                    comboTimeRef.current = COMBO_MAX_TIME_MS;
                                    actionMsg = "DOUBLE JUMP!";
                                } else if (isFastJump && floors >= 1) {
                                    newCombo = 1;
                                    comboTimeRef.current = COMBO_MAX_TIME_MS;
                                    actionMsg = "COMBO START!";
                                }
                            } else {
                                newCombo += floors;
                                comboTimeRef.current = COMBO_MAX_TIME_MS;
                                if (floors >= 2) actionMsg = "SUPER JUMP!";
                                else actionMsg = `${newCombo}x COMBO!`;
                            }

                            const multiplier = newCombo > 0 ? Math.pow(newCombo, 1.1) : 1;
                            scoreAdd = Math.floor(heightDiff * multiplier);

                            setGameState(prev => ({
                                ...prev,
                                combo: newCombo,
                                score: prev.score + scoreAdd,
                                maxHeight: Math.max(prev.maxHeight, Math.floor((worldFloorY - p.y) / 10)),
                                actionText: actionMsg ? { text: actionMsg, opacity: 1, x: player.x, y: player.y - 40 } : prev.actionText
                            }));
                        } else if (heightDiff < -10) {
                            setGameState(prev => ({ ...prev, combo: 0, comboTimer: 0 }));
                            comboTimeRef.current = 0;
                        }
                        lastPlatformY.current = p.y;
                    }
                    }
                });
                }

                player.grounded = isNowGrounded;

                // Camera Catch-up
                const targetCamY = player.y - dimensions.logicalHeight * 0.55;
                if (targetCamY < cameraY.current) {
                    cameraY.current += (targetCamY - cameraY.current) * 0.15;
                }
                if (cameraY.current > 0) cameraY.current = 0; 
                if (player.y - dimensions.logicalHeight * 0.4 < cameraY.current) {
                    cameraY.current = player.y - dimensions.logicalHeight * 0.4;
                }

                const bottomBound = cameraY.current + dimensions.logicalHeight;
                platformsRef.current = platformsRef.current.filter(p => p.y < bottomBound + 100);
                
                const highestPlatformY = platformsRef.current.length > 0 ? Math.min(...platformsRef.current.map(p => p.y)) : cameraY.current;
                if (highestPlatformY > cameraY.current - 200) {
                for(let i=1; i<=3; i++) {
                    platformsRef.current.push(generatePlatform(highestPlatformY - i * 140));
                }
                }

                if (player.y > cameraY.current + dimensions.logicalHeight + 50) {
                setGameState(prev => ({ 
                    ...prev, 
                    status: GameStatus.GAMEOVER,
                    bestScore: Math.max(prev.bestScore, prev.score)
                }));
                }

                const currentSpeed = Math.sqrt(player.vx ** 2 + player.vy ** 2);
                setGameState(prev => ({ 
                    ...prev, 
                    height: Math.max(prev.height, Math.floor((worldFloorY - player.y) / 10)),
                    comboTimer: Math.max(0, comboTimeRef.current / COMBO_MAX_TIME_MS),
                    maxSpeed: Math.max(prev.maxSpeed, currentSpeed)
                }));
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return; // Safer check
                const ctx = canvas.getContext('2d', { alpha: false });
                if (!ctx) return;
                
                const dpr = window.devicePixelRatio || 1;
                
                // Resize if dimensions changed
                if (canvas.width !== dimensions.width * dpr || canvas.height !== dimensions.height * dpr) {
                    canvas.width = dimensions.width * dpr;
                    canvas.height = dimensions.height * dpr;
                }

                // 1. Reset transform to clear screen in physical pixels
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = '#020617'; // Pillarbox color
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 2. Setup Logical System
                ctx.scale(dpr * dimensions.scale, dpr * dimensions.scale);

                // 3. Calculate Centering
                const logicalCanvasWidth = dimensions.width / dimensions.scale;
                const xOffset = (logicalCanvasWidth - LOGICAL_WIDTH) / 2;

                ctx.translate(xOffset, 0);

                // --- CLIPPING FIX ---
                ctx.beginPath();
                ctx.rect(0, 0, LOGICAL_WIDTH, dimensions.logicalHeight);
                ctx.clip();

                const worldFloorY = dimensions.logicalHeight - FLOOR_HEIGHT;

                // CRITICAL FIX: Ensure height is finite and positive before creating gradient
                if (Number.isFinite(dimensions.logicalHeight) && dimensions.logicalHeight > 0) {
                    const gradient = ctx.createLinearGradient(0, 0, 0, dimensions.logicalHeight);
                    gradient.addColorStop(0, '#020617');
                    gradient.addColorStop(1, '#1e1b4b');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, LOGICAL_WIDTH, dimensions.logicalHeight);
                } else {
                    ctx.fillStyle = '#020617';
                    ctx.fillRect(0, 0, LOGICAL_WIDTH, 800);
                }

                // Draw borders for the game area
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, LOGICAL_WIDTH, dimensions.logicalHeight);

                // Safe drawing for stars
                starsRef.current.forEach(star => {
                    let screenY = (star.y - (cameraY.current * star.speed)) % dimensions.logicalHeight;
                    if (screenY < 0) screenY += dimensions.logicalHeight;

                    if (Number.isFinite(screenY)) {
                        const twinkle = Math.random() > 0.95 ? 0 : 1;
                        ctx.globalAlpha = star.alpha * twinkle;
                        ctx.fillStyle = '#e0f2fe';
                        ctx.beginPath();
                        ctx.arc(star.x, screenY, star.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.globalAlpha = 1.0;

                ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
                ctx.lineWidth = 1;
                const gridOffsetY = -cameraY.current % 60;
                if (Number.isFinite(dimensions.logicalHeight)) {
                    for (let y = gridOffsetY; y < dimensions.logicalHeight; y += 60) {
                        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(LOGICAL_WIDTH, y); ctx.stroke();
                    }
                }

                ctx.save();
                ctx.translate(0, -cameraY.current);

                if (cameraY.current > -dimensions.logicalHeight) {
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(0, worldFloorY, LOGICAL_WIDTH, FLOOR_HEIGHT);
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#06b6d4';
                    ctx.fillStyle = '#06b6d4';
                    ctx.fillRect(0, worldFloorY, LOGICAL_WIDTH, 5);
                    ctx.shadowBlur = 0;
                }
                
                platformsRef.current.forEach(p => {
                const isMoving = p.type === 'moving';
                ctx.shadowBlur = isMoving ? 15 : 10;
                ctx.shadowColor = isMoving ? '#ec4899' : '#06b6d4'; 
                
                const pGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
                if (isMoving) {
                    pGrad.addColorStop(0, '#f9a8d4');
                    pGrad.addColorStop(1, '#db2777');
                } else {
                    pGrad.addColorStop(0, '#67e8f9');
                    pGrad.addColorStop(1, '#0891b2');
                }
                ctx.fillStyle = pGrad;
                drawRoundRect(ctx, p.x, p.y, p.width, p.height, 4); 
                ctx.fill();
                ctx.shadowBlur = 0;
                });

                particlesRef.current.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1.0;

                const player = playerRef.current;
                
                const intensity = Math.min(gameState.combo, 12) / 12; 
                let r, g, b;
                if (intensity < 0.33) {
                const t = intensity * 3;
                r = 34 + (168 - 34) * t; g = 211 + (85 - 211) * t; b = 238 + (247 - 238) * t;
                } else if (intensity < 0.66) {
                const t = (intensity - 0.33) * 3;
                r = 168 + (236 - 168) * t; g = 85 + (72 - 85) * t; b = 247 + (153 - 247) * t;
                } else {
                const t = (intensity - 0.66) * 3;
                r = 236 + (255 - 236) * t; g = 72 + (255 - 72) * t; b = 153 + (255 - 153) * t;
                }
                const playerColor = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;

                const speed = Math.sqrt(player.vx ** 2 + player.vy ** 2);
                if (speed > 10 || gameState.combo > 2) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = playerColor;
                for (let i = 1; i <= 3; i++) {
                    drawRoundRect(ctx, player.x - player.vx * (i * 1.5), player.y - player.vy * (i * 1.5), player.width, player.height, 8);
                    ctx.fill();
                }
                ctx.restore();
                }

                ctx.shadowBlur = 20 + (intensity * 10);
                ctx.shadowColor = playerColor;
                ctx.fillStyle = playerColor;
                drawRoundRect(ctx, player.x, player.y, player.width, player.height, 8);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Eyes
                ctx.fillStyle = 'white';
                const lookX = player.vx > 1 ? 4 : (player.vx < -1 ? -4 : 0);
                const lookY = player.vy < -2 ? -4 : (player.vy > 2 ? 4 : 0);
                
                // Left Eye
                ctx.save();
                ctx.translate(player.x + 10 + lookX, player.y + 10 + lookY);
                ctx.scale(4, 6);
                ctx.beginPath();
                ctx.arc(0, 0, 1, 0, 2 * Math.PI);
                ctx.restore();
                ctx.fill();

                // Right Eye
                ctx.save();
                ctx.translate(player.x + 22 + lookX, player.y + 10 + lookY);
                ctx.scale(4, 6);
                ctx.beginPath();
                ctx.arc(0, 0, 1, 0, 2 * Math.PI);
                ctx.restore();
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath(); ctx.arc(player.x + 11 + lookX, player.y + 10 + lookY, 1.5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(player.x + 23 + lookX, player.y + 10 + lookY, 1.5, 0, Math.PI*2); ctx.fill();

                if (gameState.actionText) {
                    ctx.save();
                    ctx.globalAlpha = gameState.actionText.opacity;
                    ctx.fillStyle = '#fff'; 
                    ctx.font = '900 24px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(gameState.actionText.text, gameState.actionText.x + 16, gameState.actionText.y);
                    ctx.fillText(gameState.actionText.text, gameState.actionText.x + 16, gameState.actionText.y);
                    ctx.restore();
                }

                ctx.restore();

                const deathLine = cameraY.current + dimensions.logicalHeight + 50;
                const distToDeath = deathLine - player.y;
                
                if (distToDeath < 350 && gameState.status === GameStatus.PLAYING) {
                    if (Number.isFinite(dimensions.logicalHeight) && dimensions.logicalHeight > 150) {
                        const warningAlpha = Math.max(0, (350 - distToDeath) / 350);
                        const warningGrad = ctx.createLinearGradient(0, dimensions.logicalHeight, 0, dimensions.logicalHeight - 150);
                        warningGrad.addColorStop(0, `rgba(220, 38, 38, ${warningAlpha * 0.8})`);
                        warningGrad.addColorStop(1, 'rgba(220, 38, 38, 0)');
                        ctx.fillStyle = warningGrad;
                        ctx.fillRect(0, dimensions.logicalHeight - 150, LOGICAL_WIDTH, 150);
                    }
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => keysRef.current[e.key] = true;
                const handleKeyUp = (e) => keysRef.current[e.key] = false;

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                let frameId;
                const loop = (time) => {
                const dt = lastTime.current ? (time - lastTime.current) / 16.67 : 1;
                lastTime.current = time;
                try {
                    update(dt);
                    draw();
                } catch (e) {
                    console.error("Game loop error:", e);
                }
                frameId = requestAnimationFrame(loop);
                };

                frameId = requestAnimationFrame(loop);
                
                if (dimensions.logicalHeight > 0) {
                    initPlatforms(dimensions.logicalHeight - FLOOR_HEIGHT);
                    initStars(dimensions.logicalHeight);
                }

                return () => {
                window.removeEventListener('keydown', handleKeyDown);
                window.removeEventListener('keyup', handleKeyUp);
                cancelAnimationFrame(frameId);
                };
            }, [gameState.status, dimensions]);

            const handleStart = () => {
                if (!musicEngine.isPlaying) {
                    musicEngine.start();
                }
                resetGame();
            };

            return (
                <div 
                    ref={containerRef}
                    className="relative w-full h-full bg-black overflow-hidden touch-none select-none"
                    onContextMenu={(e) => e.preventDefault()}
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                >
                <div className="absolute inset-0 scanlines z-20 pointer-events-none"></div>
                <div className="absolute inset-0 vignette z-20 pointer-events-none"></div>
                
                <canvas
                    ref={canvasRef}
                    style={{ width: '100%', height: '100%' }}
                    className="block"
                />

                {gameState.status === GameStatus.PLAYING && (
                    <HUD 
                    score={gameState.score} 
                    height={gameState.height} 
                    combo={gameState.combo}
                    comboTimer={gameState.comboTimer}
                    speed={Math.sqrt(playerRef.current.vx ** 2 + playerRef.current.vy ** 2)}
                    isMuted={gameState.isMuted}
                    onToggleMute={toggleMute}
                    />
                )}

                {gameState.status === GameStatus.MENU && (
                    <div className="absolute inset-0 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center space-y-8 p-6 text-center z-30 pointer-events-auto">
                    <div className="space-y-2 animate-pulse">
                        <h1 className="text-6xl md:text-8xl font-orbitron font-black text-transparent bg-clip-text bg-gradient-to-br from-cyan-400 via-purple-500 to-pink-500 italic tracking-tighter drop-shadow-2xl filter brightness-110">
                        NEON<br/>BUNNY
                        </h1>
                        <div className="h-1 w-32 bg-cyan-500 mx-auto rounded-full shadow-[0_0_10px_cyan]"></div>
                        <p className="text-cyan-300 font-orbitron uppercase tracking-[0.4em] text-[10px] font-bold">Infinite Momentum Jumper</p>
                    </div>

                    <div className="max-w-xs space-y-4 text-zinc-300 text-sm bg-black/60 p-6 rounded-3xl border border-white/10 backdrop-blur-xl shadow-2xl">
                        <p className="leading-relaxed">
                            <span className="text-cyan-400 font-bold border-b border-cyan-500/50">CONTROLS</span>
                            <br/>
                            <span className="text-white font-bold">PC:</span> Arrows/WASD + Space
                            <br/>
                            <span className="text-yellow-400 font-bold">Mobile:</span> Touch Sides to Run, Swipe Up to Jump.
                        </p>
                        <div className="grid grid-cols-2 gap-3 pt-2 text-[10px]">
                        <div className="bg-white/5 p-2 rounded border border-white/5 hover:border-pink-500 transition-colors">
                            <span className="block text-pink-500 font-bold">SPEED</span>
                            <span className="text-zinc-500">Momentum = Height</span>
                        </div>
                        <div className="bg-white/5 p-2 rounded border border-white/5 hover:border-yellow-500 transition-colors">
                            <span className="block text-yellow-500 font-bold">COMBO</span>
                            <span className="text-zinc-500">Don't Stop Moving</span>
                        </div>
                        </div>
                    </div>

                    <button
                        onClick={handleStart}
                        className="group relative px-12 py-5 bg-white text-black font-orbitron font-black text-2xl rounded-xl transition-all hover:scale-105 active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.4)] overflow-hidden cursor-pointer"
                    >
                        <div className="absolute inset-0 bg-gradient-to-r from-cyan-300 via-purple-300 to-pink-300 opacity-0 group-hover:opacity-100 transition-opacity"></div>
                        <span className="relative z-10">RUN . EXE</span>
                    </button>
                    
                    {gameState.bestScore > 0 && (
                        <p className="text-zinc-500 font-orbitron text-xs uppercase tracking-widest animate-pulse">
                        Personal Best: {Math.floor(gameState.bestScore)}
                        </p>
                    )}
                    </div>
                )}

                {gameState.status === GameStatus.GAMEOVER && (
                    <GameOver 
                    score={gameState.score} 
                    height={gameState.height} 
                    maxSpeed={gameState.maxSpeed}
                    combo={gameState.combo}
                    onRestart={handleStart} 
                    />
                )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>